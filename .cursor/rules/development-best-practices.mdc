---
globs: *.dart
description: Flutter and GetX development best practices
---

# Flutter & GetX Development Best Practices

## Code Organization
### Feature-First Architecture
Organize code by features rather than type:
```
✅ Good:
lib/features/auth/
├── controllers/
├── views/
└── bindings/

❌ Avoid:
lib/
├── controllers/
├── views/
└── bindings/
```

### File Structure per Feature
```
feature_name/
├── controllers/     # Feature-specific business logic
├── views/          # UI components and screens
├── bindings/       # Dependency injection
├── widgets/        # Feature-specific widgets
└── models/         # Feature-specific data models (if needed)
```

## Controller Best Practices
### Single Responsibility
```dart
// ✅ Good: One controller per feature
class AuthController extends GetxController {
  // Only authentication logic
}

// ❌ Avoid: God controller with multiple responsibilities
class AppController extends GetxController {
  // Auth, navigation, data, UI state all mixed together
}
```

### Reactive State Management
```dart
// ✅ Good: Use observables for reactive updates
final isLoading = false.obs;
final user = Rxn<UserModel>();

// ❌ Avoid: Manual setState calls
bool isLoading = false;
void updateLoading(bool value) {
  isLoading = value;
  update();
}
```

### Lifecycle Management
```dart
class FeatureController extends GetxController {
  @override
  void onInit() {
    super.onInit();
    // Initialize data, setup listeners
  }

  @override
  void onReady() {
    super.onReady();
    // Widget is ready, start animations or fetch initial data
  }

  @override
  void onClose() {
    super.onClose();
    // Clean up resources, cancel subscriptions
  }
}
```

## View Best Practices
### Separate UI from Business Logic
```dart
// ✅ Good: Keep controllers out of views
class LoginView extends GetView<LoginController> {
  @override
  Widget build(BuildContext context) {
    return Obx(() => controller.isLoading.value
        ? CircularProgressIndicator()
        : LoginForm());
  }
}

// ❌ Avoid: Business logic in views
class LoginView extends StatelessWidget {
  final AuthService _authService = Get.find();

  // Business logic mixed with UI
}
```

### Use GetView/GetWidget
```dart
// ✅ Preferred for single controller
class ProfileView extends GetView<ProfileController> {
  // controller is automatically available
}

// ✅ For multiple controllers or no controller
class CustomView extends GetWidget<FeatureController> {
  // Use GetWidget when you need more flexibility
}
```

## Data Layer Best Practices
### Repository Pattern
```dart
// ✅ Good: Abstract data access
class UserRepository {
  final ApiProvider _apiProvider;
  final LocalStorage _localStorage;

  Future<User> getUser(String id) async {
    // Try cache first, then network
  }
}

// ❌ Avoid: Direct API calls in controllers
class UserController extends GetxController {
  Future<void> fetchUser() async {
    final response = await http.get('/user'); // Direct API call
  }
}
```

### Error Handling
```dart
// ✅ Good: Centralized error handling
class ApiService {
  Future<T> handleRequest<T>(Future<T> Function() request) async {
    try {
      return await request();
    } on DioError catch (e) {
      throw _handleDioError(e);
    } catch (e) {
      throw GenericException('Unknown error occurred');
    }
  }
}
```

## Performance Optimization
### Efficient List Updates
```dart
// ✅ Good: Use RxList for efficient updates
final items = <Item>[].obs;

// Update specific items
void updateItem(int index, Item newItem) {
  if (index < items.length) {
    items[index] = newItem;
  }
}

// ❌ Avoid: Recreating entire list
void updateItems(List<Item> newItems) {
  items.assignAll(newItems); // Less efficient for small changes
}
```

### Memory Management
```dart
class HeavyController extends GetxController {
  late Worker _worker;

  @override
  void onInit() {
    super.onInit();
    _worker = ever(userId, _fetchUserData);
  }

  @override
  void onClose() {
    _worker.dispose(); // Clean up workers
    super.onClose();
  }
}
```

## Testing Guidelines
### Unit Tests Structure
```
test/
├── unit/
│   ├── controllers/
│   ├── services/
│   └── utils/
└── widget/
    └── features/
```

### Mock Dependencies
```dart
// ✅ Good: Mock external dependencies
@GenerateMocks([ApiService, LocalStorage])
void main() {
  late MockApiService mockApiService;
  late FeatureController controller;

  setUp(() {
    mockApiService = MockApiService();
    controller = FeatureController(apiService: mockApiService);
  });
}
```

## Code Style Guidelines
### Naming Conventions
```dart
// ✅ Good
class UserProfileController extends GetxController
final RxBool isLoading = false.obs;
void fetchUserData() {}

// ❌ Avoid
class userprofilecontroller extends GetxController
var isloading = false.obs;
void fetch_user_data() {}
```

### Constants and Magic Numbers
```dart
// ✅ Good: Use named constants
class AppConstants {
  static const int maxRetries = 3;
  static const Duration timeout = Duration(seconds: 30);
}

// ❌ Avoid: Magic numbers
Future.delayed(Duration(seconds: 30));
for (int i = 0; i < 3; i++) {}
```

## Security Best Practices
### API Key Management
```dart
// ✅ Good: Environment-based configuration
class Config {
  static String get apiKey => const String.fromEnvironment('API_KEY');
}

// ❌ Avoid: Hardcoded secrets
const apiKey = 'sk-1234567890abcdef';
```

### Input Validation
```dart
// ✅ Good: Validate user input
String? validateEmail(String? value) {
  if (value == null || value.isEmpty) {
    return 'Email is required';
  }
  if (!GetUtils.isEmail(value)) {
    return 'Please enter a valid email';
  }
  return null;
}
```

## Git Workflow
### Commit Message Format
```
feat: add user authentication
fix: resolve login timeout issue
docs: update API documentation
style: format code with dartfmt
refactor: optimize image loading
test: add unit tests for user controller
```

### Branch Naming
```
feature/auth-flow
bugfix/login-crash
hotfix/payment-gateway
```

This rule applies to all Dart files in the Flutter project.