---
globs: lib/**/*.dart
description: Design system, theming, and UI consistency patterns
---

# Design System and Theme Guidelines

## Theme Structure
The app uses Flutter's ThemeData with custom extensions for consistent styling.

### App Theme Setup
```dart
// ✅ Good: Centralized theme configuration
class AppTheme {
  static ThemeData get lightTheme {
    return ThemeData(
      primaryColor: AppColors.primary,
      colorScheme: ColorScheme.light(
        primary: AppColors.primary,
        secondary: AppColors.secondary,
        background: AppColors.background,
        surface: AppColors.surface,
        error: AppColors.error,
      ),
      textTheme: TextTheme(
        displayLarge: AppTextStyles.displayLarge,
        displayMedium: AppTextStyles.displayMedium,
        bodyLarge: AppTextStyles.bodyLarge,
        bodyMedium: AppTextStyles.bodyMedium,
        labelLarge: AppTextStyles.labelLarge,
      ),
      appBarTheme: AppBarTheme(
        backgroundColor: AppColors.primary,
        foregroundColor: AppColors.onPrimary,
        elevation: 0,
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: AppButtonStyles.primary,
      ),
    );
  }
}
```

### Color Palette
```dart
// ✅ Good: Centralized color definitions
class AppColors {
  // Primary colors
  static const Color primary = Color(0xFF007AFF);
  static const Color primaryVariant = Color(0xFF5856D6);
  static const Color secondary = Color(0xFFFF9500);

  // Neutral colors
  static const Color background = Color(0xFFFFFFFF);
  static const Color surface = Color(0xFFF8F9FA);
  static const Color surfaceVariant = Color(0xFFF2F2F7);

  // Text colors
  static const Color onPrimary = Color(0xFFFFFFFF);
  static const Color onBackground = Color(0xFF1C1C1E);
  static const Color onSurface = Color(0xFF1C1C1E);
  static const Color textSecondary = Color(0xFF8E8E93);

  // Status colors
  static const Color success = Color(0xFF34C759);
  static const Color error = Color(0xFFFF3B30);
  static const Color warning = Color(0xFFFF9500);
  static const Color info = Color(0xFF007AFF);

  // Semantic colors
  static const Color border = Color(0xFFE5E5EA);
  static const Color divider = Color(0xFFE5E5EA);
}
```

### Typography System
```dart
// ✅ Good: Consistent text styles
class AppTextStyles {
  static const TextStyle displayLarge = TextStyle(
    fontSize: 32,
    fontWeight: FontWeight.bold,
    height: 1.2,
    letterSpacing: -0.5,
  );

  static const TextStyle displayMedium = TextStyle(
    fontSize: 28,
    fontWeight: FontWeight.bold,
    height: 1.2,
    letterSpacing: -0.5,
  );

  static const TextStyle bodyLarge = TextStyle(
    fontSize: 16,
    fontWeight: FontWeight.normal,
    height: 1.5,
    letterSpacing: 0.1,
  );

  static const TextStyle bodyMedium = TextStyle(
    fontSize: 14,
    fontWeight: FontWeight.normal,
    height: 1.5,
    letterSpacing: 0.1,
  );

  static const TextStyle labelLarge = TextStyle(
    fontSize: 16,
    fontWeight: FontWeight.w600,
    height: 1.2,
    letterSpacing: 0.1,
  );
}
```

## Button System
```dart
// ✅ Good: Consistent button styles
class AppButtonStyles {
  static ButtonStyle get primary => ElevatedButton.styleFrom(
        backgroundColor: AppColors.primary,
        foregroundColor: AppColors.onPrimary,
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8),
        ),
        elevation: 0,
        textStyle: AppTextStyles.labelLarge,
      );

  static ButtonStyle get secondary => OutlinedButton.styleFrom(
        side: BorderSide(color: AppColors.primary),
        foregroundColor: AppColors.primary,
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8),
        ),
        textStyle: AppTextStyles.labelLarge,
      );

  static ButtonStyle get ghost => TextButton.styleFrom(
        foregroundColor: AppColors.primary,
        textStyle: AppTextStyles.labelLarge,
      );
}
```

## Spacing System
```dart
// ✅ Good: Consistent spacing values
class AppSpacing {
  static const double xs = 4;
  static const double sm = 8;
  static const double md = 16;
  static const double lg = 24;
  static const double xl = 32;
  static const double xxl = 48;
}
```

## Component Guidelines
### Custom Widgets Structure
```dart
// ✅ Good: Reusable component with proper theming
class CustomCard extends StatelessWidget {
  final Widget child;
  final EdgeInsetsGeometry? padding;
  final Color? backgroundColor;
  final double? borderRadius;

  const CustomCard({
    super.key,
    required this.child,
    this.padding,
    this.backgroundColor,
    this.borderRadius,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      padding: padding ?? EdgeInsets.all(AppSpacing.md),
      decoration: BoxDecoration(
        color: backgroundColor ?? theme.colorScheme.surface,
        borderRadius: BorderRadius.circular(borderRadius ?? 12),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: child,
    );
  }
}
```

### Responsive Design
```dart
// ✅ Good: Responsive layout patterns
class ResponsiveLayout extends StatelessWidget {
  final Widget mobile;
  final Widget? tablet;
  final Widget desktop;

  const ResponsiveLayout({
    super.key,
    required this.mobile,
    this.tablet,
    required this.desktop,
  });

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        if (constraints.maxWidth >= 1200) {
          return desktop;
        } else if (constraints.maxWidth >= 768) {
          return tablet ?? mobile;
        } else {
          return mobile;
        }
      },
    );
  }
}
```

## Icon System
```dart
// ✅ Good: Centralized icon usage
class AppIcons {
  static const IconData home = Icons.home_outlined;
  static const IconData search = Icons.search;
  static const IconData profile = Icons.person_outline;
  static const IconData settings = Icons.settings_outlined;

  static IconData getIcon(String name) {
    switch (name) {
      case 'home': return home;
      case 'search': return search;
      case 'profile': return profile;
      case 'settings': return settings;
      default: return Icons.help_outline;
    }
  }
}
```

## Animation Guidelines
```dart
// ✅ Good: Consistent animations
class AppAnimations {
  static const Duration fast = Duration(milliseconds: 200);
  static const Duration normal = Duration(milliseconds: 300);
  static const Duration slow = Duration(milliseconds: 500);

  static Curve get easeOutQuart => Curves.easeOutQuart;
  static Curve get easeInOut => Curves.easeInOut;

  static Widget fadeIn({
    required Widget child,
    Duration duration = normal,
  }) {
    return TweenAnimationBuilder<double>(
      tween: Tween<double>(begin: 0, end: 1),
      duration: duration,
      curve: easeOutQuart,
      builder: (context, value, child) {
        return Opacity(opacity: value, child: child);
      },
      child: child,
    );
  }
}
```

## Dark Theme Support
```dart
// ✅ Good: Dark theme implementation
class AppTheme {
  static ThemeData get darkTheme {
    return ThemeData(
      brightness: Brightness.dark,
      colorScheme: ColorScheme.dark(
        primary: AppColors.primary,
        secondary: AppColors.secondary,
        background: const Color(0xFF1C1C1E),
        surface: const Color(0xFF2C2C2E),
        error: AppColors.error,
      ),
      // ... other theme properties
    );
  }
}
```

## Theme Usage in Widgets
```dart
// ✅ Good: Using theme values consistently
class ThemedWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Container(
      color: colorScheme.background,
      child: Text(
        'Themed Text',
        style: theme.textTheme.bodyLarge?.copyWith(
          color: colorScheme.onBackground,
        ),
      ),
    );
  }
}
```

## Best Practices
1. **Always use theme colors** instead of hardcoded colors
2. **Follow the spacing system** for consistent layouts
3. **Use semantic color names** (onPrimary, onBackground, etc.)
4. **Implement responsive design** for different screen sizes
5. **Support dark theme** from the beginning
6. **Create reusable components** for consistency
7. **Use consistent typography** throughout the app
8. **Test accessibility** with different text sizes and contrast