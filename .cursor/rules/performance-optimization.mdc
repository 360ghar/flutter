---
alwaysApply: true
description: Performance optimization patterns and best practices for 360Ghar
---

# Performance Optimization Patterns

## Overview
360Ghar implements comprehensive performance optimizations for smooth user experience, especially for property listings with images and complex data.

## Image Optimization

### Cached Network Image Implementation
```dart
class OptimizedNetworkImage extends StatelessWidget {
  final String imageUrl;
  final double? width;
  final double? height;
  final BoxFit fit;
  final BorderRadius? borderRadius;
  final Widget? placeholder;
  final Widget? errorWidget;

  const OptimizedNetworkImage({
    super.key,
    required this.imageUrl,
    this.width,
    this.height,
    this.fit = BoxFit.cover,
    this.borderRadius,
    this.placeholder,
    this.errorWidget,
  });

  @override
  Widget build(BuildContext context) {
    return CachedNetworkImage(
      imageUrl: imageUrl,
      width: width,
      height: height,
      fit: fit,
      placeholder: (context, url) => placeholder ?? ShimmerLoading(
        width: width ?? double.infinity,
        height: height ?? 200,
      ),
      errorWidget: (context, url, error) => errorWidget ?? Container(
        width: width,
        height: height,
        color: Theme.of(context).colorScheme.surfaceVariant,
        child: Icon(
          Icons.image_not_supported_outlined,
          color: Theme.of(context).colorScheme.onSurfaceVariant,
        ),
      ),
      imageBuilder: (context, imageProvider) => Container(
        decoration: BoxDecoration(
          borderRadius: borderRadius,
          image: DecorationImage(
            image: imageProvider,
            fit: fit,
          ),
        ),
      ),
      // Performance optimizations
      memCacheWidth: width != null ? (width! * MediaQuery.of(context).devicePixelRatio).round() : null,
      memCacheHeight: height != null ? (height! * MediaQuery.of(context).devicePixelRatio).round() : null,
      maxWidthDiskCache: 2048,
      maxHeightDiskCache: 2048,
      fadeInDuration: const Duration(milliseconds: 300),
      fadeOutDuration: const Duration(milliseconds: 300),
    );
  }
}
```

### Image Preloading Strategy
```dart
class ImagePreloader {
  static final Map<String, Future<void>> _preloadCache = {};

  static Future<void> preloadImages(List<String> imageUrls) async {
    final futures = <Future<void>>[];

    for (final url in imageUrls) {
      if (!_preloadCache.containsKey(url)) {
        _preloadCache[url] = _preloadImage(url);
      }
      futures.add(_preloadCache[url]!);
    }

    await Future.wait(futures);
  }

  static Future<void> _preloadImage(String url) async {
    try {
      final imageProvider = CachedNetworkImageProvider(url);
      final config = ImageConfiguration.empty;
      final completer = Completer<void>();

      final ImageStream stream = imageProvider.resolve(config);
      final listener = ImageStreamListener(
        (ImageInfo image, bool synchronousCall) {
          completer.complete();
        },
        onError: (dynamic exception, StackTrace? stackTrace) {
          completer.completeError(exception);
        },
      );

      stream.addListener(listener);
      await completer.future;
      stream.removeListener(listener);
    } catch (e) {
      debugPrint('Failed to preload image: $url');
    }
  }

  static void clearCache() {
    _preloadCache.clear();
    CachedNetworkImage.evictFromCache('');
  }
}
```

## List Optimization

### Virtualized List Implementation
```dart
class OptimizedPropertyList extends StatelessWidget {
  final List<PropertyModel> properties;
  final ScrollController? scrollController;
  final VoidCallback? onLoadMore;
  final bool isLoadingMore;
  final double itemHeight;

  const OptimizedPropertyList({
    super.key,
    required this.properties,
    this.scrollController,
    this.onLoadMore,
    this.isLoadingMore = false,
    this.itemHeight = 200,
  });

  @override
  Widget build(BuildContext context) {
    return NotificationListener<ScrollNotification>(
      onNotification: (ScrollNotification scrollInfo) {
        if (scrollInfo.metrics.pixels >= scrollInfo.metrics.maxScrollExtent - 500 &&
            !isLoadingMore &&
            onLoadMore != null) {
          onLoadMore!();
        }
        return false;
      },
      child: ListView.builder(
        controller: scrollController,
        itemCount: properties.length + (isLoadingMore ? 1 : 0),
        itemExtent: itemHeight, // Fixed height for better performance
        addAutomaticKeepAlives: false,
        addRepaintBoundaries: false,
        itemBuilder: (context, index) {
          if (index == properties.length) {
            return const LoadingMoreWidget();
          }

          final property = properties[index];
          return PropertyListItem(
            key: ValueKey(property.id), // Stable key for performance
            property: property,
          );
        },
      ),
    );
  }
}
```

### Sliver List for Complex Layouts
```dart
class SliverPropertyGrid extends StatelessWidget {
  final List<PropertyModel> properties;
  final VoidCallback? onLoadMore;
  final bool isLoadingMore;

  const SliverPropertyGrid({
    super.key,
    required this.properties,
    this.onLoadMore,
    this.isLoadingMore = false,
  });

  @override
  Widget build(BuildContext context) {
    return SliverGrid(
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 2,
        mainAxisSpacing: 16,
        crossAxisSpacing: 16,
        childAspectRatio: 0.75,
      ),
      delegate: SliverChildBuilderDelegate(
        (context, index) {
          if (index == properties.length) {
            return const LoadingMoreWidget();
          }

          final property = properties[index];
          return PropertyGridItem(
            key: ValueKey(property.id),
            property: property,
          );
        },
        childCount: properties.length + (isLoadingMore ? 1 : 0),
      ),
    );
  }
}
```

## Memory Management

### Image Cache Configuration
```dart
class ImageCacheManager {
  static void configureImageCache() {
    // Configure Flutter's image cache
    PaintingBinding.instance.imageCache.maximumSize = 100; // MB
    PaintingBinding.instance.imageCache.maximumSizeBytes = 100 << 20; // 100 MB

    // Configure CachedNetworkImage cache
    CachedNetworkImage.logLevel = CacheManagerLogLevel.debug;

    // Custom cache manager for better control
    Get.put<DefaultCacheManager>(
      DefaultCacheManager(
        Config(
          '360ghar_cache',
          stalePeriod: const Duration(days: 7),
          maxNrOfCacheObjects: 200,
          repo: JsonCacheInfoRepository(databaseName: '360ghar_cache'),
          fileService: HttpFileService(),
        ),
      ),
    );
  }

  static Future<void> clearImageCache() async {
    await CachedNetworkImage.evictFromCache('');
    await Get.find<DefaultCacheManager>().emptyCache();
  }

  static Future<void> clearOldImages() async {
    final cacheManager = Get.find<DefaultCacheManager>();
    final keys = await cacheManager.store.getKeys();

    for (final key in keys) {
      final file = await cacheManager.getFileFromCache(key);
      if (file != null && await file.exists()) {
        final age = DateTime.now().difference(await file.lastModified());
        if (age > const Duration(days: 7)) {
          await cacheManager.removeFile(key);
        }
      }
    }
  }
}
```

### Object Pool for Heavy Objects
```dart
class PropertyCardPool {
  static final Map<String, PropertyCard> _pool = {};
  static const int _maxPoolSize = 20;

  static PropertyCard? getPropertyCard(String propertyId) {
    return _pool[propertyId];
  }

  static void putPropertyCard(String propertyId, PropertyCard card) {
    if (_pool.length < _maxPoolSize) {
      _pool[propertyId] = card;
    }
  }

  static void clearPool() {
    _pool.clear();
  }

  static void removeCard(String propertyId) {
    _pool.remove(propertyId);
  }
}
```

## State Management Optimization

### Efficient Reactive Updates
```dart
class OptimizedPropertyController extends GetxController {
  final _properties = <PropertyModel>[].obs;
  final _favorites = <String>{}.obs; // Store IDs instead of full objects
  final _loadingStates = <String, bool>{}.obs; // Track loading by ID

  List<PropertyModel> get properties => _properties;

  List<PropertyModel> get favoriteProperties =>
      _properties.where((p) => _favorites.contains(p.id)).toList();

  bool isFavorite(String propertyId) => _favorites.contains(propertyId);

  bool isLoading(String propertyId) => _loadingStates[propertyId] ?? false;

  void setLoading(String propertyId, bool loading) {
    _loadingStates[propertyId] = loading;
    _loadingStates.refresh(); // Efficient update
  }

  void toggleFavorite(String propertyId) {
    if (_favorites.contains(propertyId)) {
      _favorites.remove(propertyId);
    } else {
      _favorites.add(propertyId);
    }
    _favorites.refresh();
  }

  void updateProperty(String propertyId, PropertyModel updatedProperty) {
    final index = _properties.indexWhere((p) => p.id == propertyId);
    if (index != -1) {
      _properties[index] = updatedProperty;
      // Update specific item without refreshing entire list
      _properties.refresh();
    }
  }

  // Batch updates for better performance
  void updateMultipleProperties(List<PropertyModel> updates) {
    for (final update in updates) {
      final index = _properties.indexWhere((p) => p.id == update.id);
      if (index != -1) {
        _properties[index] = update;
      }
    }
    _properties.refresh(); // Single refresh for all updates
  }
}
```

### Debounced Search
```dart
class SearchController extends GetxController {
  final searchQuery = ''.obs;
  final searchResults = <PropertyModel>[].obs;
  final isSearching = false.obs;

  Timer? _searchTimer;

  void updateSearchQuery(String query) {
    searchQuery.value = query;

    // Cancel previous search
    _searchTimer?.cancel();

    // Debounce search for 300ms
    _searchTimer = Timer(const Duration(milliseconds: 300), () {
      if (query.isNotEmpty) {
        performSearch(query);
      } else {
        searchResults.clear();
      }
    });
  }

  Future<void> performSearch(String query) async {
    isSearching.value = true;
    try {
      final results = await Get.find<SearchRepository>().search(query);
      searchResults.assignAll(results);
    } catch (e) {
      // Handle error
    } finally {
      isSearching.value = false;
    }
  }

  @override
  void onClose() {
    _searchTimer?.cancel();
    super.onClose();
  }
}
```

## Network Optimization

### Request Batching
```dart
class BatchedPropertyProvider {
  final _pendingRequests = <String, Completer<PropertyModel>>{};
  Timer? _batchTimer;
  final _batchDuration = const Duration(milliseconds: 100);

  Future<PropertyModel> getProperty(String propertyId) async {
    // Return existing request if already pending
    if (_pendingRequests.containsKey(propertyId)) {
      return _pendingRequests[propertyId]!.future;
    }

    final completer = Completer<PropertyModel>();
    _pendingRequests[propertyId] = completer;

    // Schedule batch request
    _scheduleBatchRequest();

    return completer.future;
  }

  void _scheduleBatchRequest() {
    _batchTimer?.cancel();
    _batchTimer = Timer(_batchDuration, _executeBatchRequest);
  }

  Future<void> _executeBatchRequest() async {
    final propertyIds = _pendingRequests.keys.toList();
    _pendingRequests.clear();

    try {
      final properties = await _apiProvider.getPropertiesByIds(propertyIds);

      // Complete all pending requests
      for (final property in properties) {
        final completer = _pendingRequests.remove(property.id);
        completer?.complete(property);
      }
    } catch (e) {
      // Complete with error
      for (final completer in _pendingRequests.values) {
        completer.completeError(e);
      }
      _pendingRequests.clear();
    }
  }
}
```

### Response Caching
```dart
class CachedApiProvider extends BaseApiProvider {
  final _cache = <String, CacheEntry>{};
  final _maxCacheSize = 100;

  Future<T> cachedRequest<T>(
    String cacheKey,
    Future<T> Function() request,
    Duration cacheDuration,
  ) async {
    // Check cache first
    final cached = _cache[cacheKey];
    if (cached != null && !cached.isExpired) {
      return cached.data as T;
    }

    // Make network request
    final result = await request();

    // Cache result
    _cache[cacheKey] = CacheEntry(
      data: result,
      expiresAt: DateTime.now().add(cacheDuration),
    );

    // Clean up old entries if cache is full
    if (_cache.length > _maxCacheSize) {
      _evictOldEntries();
    }

    return result;
  }

  void _evictOldEntries() {
    final entries = _cache.entries.toList()
      ..sort((a, b) => a.value.expiresAt.compareTo(b.value.expiresAt));

    final toRemove = entries.take(_cache.length - _maxCacheSize + 10);
    for (final entry in toRemove) {
      _cache.remove(entry.key);
    }
  }

  void clearCache() {
    _cache.clear();
  }

  void removeFromCache(String key) {
    _cache.remove(key);
  }
}

class CacheEntry {
  final dynamic data;
  final DateTime expiresAt;

  bool get isExpired => DateTime.now().isAfter(expiresAt);

  const CacheEntry({required this.data, required this.expiresAt});
}
```

## Performance Monitoring

### Performance Tracker
```dart
class PerformanceTracker {
  static final Map<String, Stopwatch> _timers = {};
  static final Map<String, List<int>> _metrics = {};

  static void startTimer(String operation) {
    _timers[operation] = Stopwatch()..start();
  }

  static void endTimer(String operation) {
    final timer = _timers.remove(operation);
    if (timer != null) {
      timer.stop();
      final duration = timer.elapsedMilliseconds;

      _metrics.putIfAbsent(operation, () => []);
      _metrics[operation]!.add(duration);

      // Log slow operations
      if (duration > 1000) {
        debugPrint('Slow operation: $operation took ${duration}ms');
      }
    }
  }

  static Map<String, double> getAverageMetrics() {
    final averages = <String, double>{};

    for (final entry in _metrics.entries) {
      final total = entry.value.reduce((a, b) => a + b);
      averages[entry.key] = total / entry.value.length;
    }

    return averages;
  }

  static void logMetrics() {
    final averages = getAverageMetrics();
    debugPrint('Performance Metrics:');
    averages.forEach((operation, average) {
      debugPrint('$operation: ${average.toStringAsFixed(2)}ms');
    });
  }

  static void clearMetrics() {
    _metrics.clear();
  }
}
```

### Widget Performance Overlay
```dart
class PerformanceOverlay extends StatelessWidget {
  final Widget child;
  final bool showOverlay;

  const PerformanceOverlay({
    super.key,
    required this.child,
    this.showOverlay = false,
  });

  @override
  Widget build(BuildContext context) {
    if (!showOverlay) {
      return child;
    }

    return Stack(
      children: [
        child,
        Positioned(
          top: 50,
          right: 10,
          child: Container(
            padding: const EdgeInsets.all(8),
            color: Colors.black.withOpacity(0.7),
            child: StreamBuilder<Map<String, double>>(
              stream: Stream.periodic(const Duration(seconds: 5), (_) => PerformanceTracker.getAverageMetrics()),
              builder: (context, snapshot) {
                if (!snapshot.hasData) return const SizedBox();

                final metrics = snapshot.data!;
                return Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: metrics.entries.map((entry) {
                    return Text(
                      '${entry.key}: ${entry.value.toStringAsFixed(1)}ms',
                      style: const TextStyle(color: Colors.white, fontSize: 10),
                    );
                  }).toList(),
                );
              },
            ),
          ),
        ),
      ],
    );
  }
}
```

## Best Practices

### 1. Image Loading
- Use cached network images
- Implement lazy loading
- Preload critical images
- Configure appropriate cache sizes
- Handle image errors gracefully

### 2. List Performance
- Use itemExtent for uniform items
- Implement virtualization
- Avoid unnecessary rebuilds
- Use const constructors
- Implement efficient keys

### 3. Memory Management
- Monitor memory usage
- Implement object pooling
- Clean up resources properly
- Use weak references where appropriate
- Profile memory leaks

### 4. Network Optimization
- Implement request batching
- Use intelligent caching
- Compress requests/responses
- Handle offline scenarios
- Monitor network performance

### 5. State Management
- Use efficient reactive updates
- Implement debouncing for search
- Batch state updates
- Use appropriate observable types
- Profile state change performance

### 6. Rendering Performance
- Minimize widget rebuilds
- Use const widgets where possible
- Implement proper keys
- Profile rendering performance
- Use performance overlay in development

### 7. Bundle Optimization
- Lazy load feature modules
- Tree shake unused code
- Optimize asset sizes
- Use webp for images
- Implement code splitting

### 8. Monitoring and Profiling
- Use Flutter DevTools
- Monitor performance metrics
- Profile memory usage
- Track network requests
- Log performance issues

This rule applies to all performance-critical code in the 360Ghar Flutter application.