---
globs: *.dart
description: GetX state management and routing patterns
---

# GetX Architecture and Routing

## State Management Pattern
This project uses GetX for reactive state management. Follow these patterns:

### Controllers
```dart
class FeatureController extends GetxController {
  // Observable variables
  final isLoading = false.obs;
  final items = <Item>[].obs;

  // Non-observable variables
  late final ApiService _apiService;

  @override
  void onInit() {
    super.onInit();
    _apiService = Get.find<ApiService>();
    fetchData();
  }

  @override
  void onClose() {
    // Cleanup resources
    super.onClose();
  }

  Future<void> fetchData() async {
    isLoading.value = true;
    try {
      final result = await _apiService.getData();
      items.assignAll(result);
    } catch (e) {
      // Handle error
    } finally {
      isLoading.value = false;
    }
  }
}
```

### Reactive Programming
```dart
// In Controller
final RxInt counter = 0.obs;
final RxString name = ''.obs;

// In View
Obx(() => Text('Count: ${controller.counter.value}')),
TextField(
  onChanged: (value) => controller.name.value = value,
),
```

## Dependency Injection
Use GetX bindings for dependency injection:

### App-level Bindings (`lib/core/bindings/`)
```dart
class AppBinding extends Bindings {
  @override
  void dependencies() {
    Get.lazyPut<ApiService>(() => ApiService());
    Get.lazyPut<AuthController>(() => AuthController());
  }
}
```

### Feature-level Bindings
```dart
class FeatureBinding extends Bindings {
  @override
  void dependencies() {
    Get.lazyPut<FeatureController>(() => FeatureController());
  }
}
```

## Routing
Use named routes with GetX:

### Route Definition (`lib/core/routes/`)
```dart
class AppPages {
  static final routes = [
    GetPage(
      name: '/',
      page: () => SplashView(),
      binding: SplashBinding(),
    ),
    GetPage(
      name: '/login',
      page: () => LoginView(),
      binding: LoginBinding(),
      middlewares: [AuthMiddleware()],
    ),
  ];
}
```

### Navigation
```dart
// Navigate to named route
Get.toNamed('/login');

// With parameters
Get.toNamed('/property/123', arguments: {'id': 123});

// Replace current route
Get.offNamed('/dashboard');

// Replace all routes
Get.offAllNamed('/login');

// Go back
Get.back();
```

## Reactive UI Updates
```dart
// In View
Obx(() {
  return controller.isLoading.value
      ? CircularProgressIndicator()
      : ListView.builder(
          itemCount: controller.items.length,
          itemBuilder: (context, index) {
            final item = controller.items[index];
            return ListTile(title: Text(item.name));
          },
        );
}),
```

## Reactive Forms
```dart
// In Controller
final email = ''.obs;
final password = ''.obs;
final isFormValid = false.obs;

void validateForm() {
  isFormValid.value = email.isNotEmpty && password.isNotEmpty;
}

// In View
TextField(
  onChanged: (value) {
    controller.email.value = value;
    controller.validateForm();
  },
),
```

## Lifecycle Management
```dart
class MyController extends GetxController {
  final RxBool isVisible = true.obs;

  @override
  void onInit() {
    super.onInit();
    // Called when controller is initialized
  }

  @override
  void onReady() {
    super.onReady();
    // Called after widget is rendered
  }

  @override
  void onClose() {
    super.onClose();
    // Called when controller is removed
  }
}
```

## Best Practices
1. **Use `.obs` for reactive variables**
2. **Prefer `Get.find<T>()` over constructor injection**
3. **Use lazyPut for better performance**
4. **Implement proper lifecycle methods**
5. **Use middlewares for route guards**
6. **Keep business logic in controllers, not views**
7. **Use reactive programming for complex state changes**